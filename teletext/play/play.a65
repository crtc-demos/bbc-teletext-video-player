#define oswrch $ffee
#define osbyte $fff4
#define osfind $ffce
#define osgbpb $ffd1

; 10KHz * 100 = 1000000
#define HZ0 64
#define HZ1 66
#define HZ2 15
#define HZ3 0
; 1000000 / Hz
;   - 12.5KHz -> 80
;   - 10KHz   -> 100
;   - 8KHz    -> 125
#define RHZ 100


	*= $e00
	
	.(
	; open files, prebuffer
	jsr openfile
	jsr loadblock
	jsr queueblock
	jsr openfile_v
	jsr loadblock_v
	jsr queueblock_v

	; start audio
	jsr initptr
	jsr initfreq
	jsr inittimer1irq

	; start video
	jsr initptr_v
	jsr setup_event

	; poll a/v to get new blocks
	jsr pollmedia

	rts
	.)

handle
	.byt 0

openfile
	.(
	lda #$40
	ldx #<filename
	ldy #>filename
	jsr osfind
	sta handle
	rts
	.)

filename
	.asc "noise10k", 0

gbpb_block
gbpb_fh
	.byt 0
gbpb_io
	.byt 0
	.byt 0
	.byt 0
	.byt 0
gbpb_tfer
	.byt 0
	.byt 0
	.byt 0
	.byt 0
gbpb_seq
	.byt 0
	.byt 0
	.byt 0
	.byt 0

loadblock
	.(
	lda handle
	sta gbpb_fh
	lda #0
	sta gbpb_io
	lda #$3C
	sta gbpb_io+1
	lda #<4096
	sta gbpb_tfer
	lda #>4096
	sta gbpb_tfer+1
	lda #<0
	sta gbpb_seq
	lda #>0
	sta gbpb_seq+1
	lda #0/65536
	sta gbpb_seq+2
	ldx #<gbpb_block
	ldy #>gbpb_block
	lda #3
	jsr osgbpb
	rts
	.)

nextblock
	.(
	lda handle
	sta gbpb_fh
	lda #0
	sta gbpb_io
	lda $13
	cmp #2
	beq secondbuf
	lda #$3C
	jmp chosenbuf
secondbuf
	lda #$4C
chosenbuf
	sta gbpb_io+1
	
	; received request, clear.
	stz $13
	
	lda #<4096
	sta gbpb_tfer
	lda #>4096
	sta gbpb_tfer+1
	ldx #<gbpb_block
	ldy #>gbpb_block
	lda #3
	jsr osgbpb
	rts
	.)

; Queue the block after the first.
queueblock
	.(
	lda #2
	sta $13
	jsr nextblock
	rts
	.)

handle_v
	.byt 0

openfile_v
	.(
	lda #$40
	ldx #<filename_v
	ldy #>filename_v
	jsr osfind
	sta handle_v
	rts
	.)

filename_v
	.asc "aphexsqz", 0

gbpb_block_v
gbpb_fh_v
	.byt 0
gbpb_io_v
	.byt 0
	.byt 0
	.byt 0
	.byt 0
gbpb_tfer_v
	.byt 0
	.byt 0
	.byt 0
	.byt 0
gbpb_seq_v
	.byt 0
	.byt 0
	.byt 0
	.byt 0

loadblock_v
	.(
	lda handle_v
	sta gbpb_fh_v
	lda #0
	sta gbpb_io_v
	lda #$5C
	sta gbpb_io_v+1
	lda #<4096
	sta gbpb_tfer_v
	lda #>4096
	sta gbpb_tfer_v+1
	lda #<0
	sta gbpb_seq_v
	lda #>0
	sta gbpb_seq_v+1
	lda #0/65536
	sta gbpb_seq_v+2
	ldx #<gbpb_block_v
	ldy #>gbpb_block_v
	lda #3
	jsr osgbpb
	
	; buffer 1 is ready.
	lda #1
	sta $0b
	rts
	.)

	; $0a is the buffer to reload (1 or 2).
	; $0b is set to 1 when buffer 1 is ready.
	; $0c is set to 1 when buffer 2 is ready.

nextblock_v
	.(
	lda handle_v
	sta gbpb_fh_v
	stz gbpb_io_v
	
	lda $0a
	pha
	cmp #2
	beq secondbuf
	lda #$5C
	jmp chosenbuf
secondbuf
	lda #$6C
chosenbuf
	sta gbpb_io_v+1
	
	; clear video request
	stz $0a
	
	lda #<4096
	sta gbpb_tfer_v
	lda #>4096
	sta gbpb_tfer_v+1
	ldx #<gbpb_block_v
	ldy #>gbpb_block_v
	lda #3
	jsr osgbpb
	
	plx
	dex
	lda #1
	sta $0b,x
	
	rts
	.)

queueblock_v
	.(
	lda #2
	sta $0a
	jsr nextblock_v
	rts
	.)

initptr_v
	.(
	lda #0
	ldx #$5C
	sta $00
	stx $01
	
	; $09 is current video buffer (zero).
	stz $09
	
	rts
	.)

; poll $0a for video-block requests and $13 for audio-block requests.

pollmedia
	.(
repeat
	lda $0a
	beq skipvideo
	jsr nextblock_v
skipvideo
	lda $13
	beq repeat

	jsr nextblock
	jmp repeat
	
	rts
	.)

setup_event
	.(
	lda #<render_event
	ldx #>render_event
	;sta $220
	;stx $221
	
	; enable vsync event
	;lda #14
	;ldx #4
	;jsr osbyte
	
	; renderer busy
	stz $08
	
	; frames outstanding
	stz $18
	
	; stalled on video block load
	stz $19
	
	rts
	.)

render_event
	.(
	php
	pha
	phx
	phy
	
	lda $17
	cmp #HZ3
	bcc no_new_frame
	bne new_frame
	lda $16
	cmp #HZ2
	bcc no_new_frame
	bne new_frame
	lda $15
	cmp #HZ1
	bcc no_new_frame
	bne new_frame
	lda $14
	cmp #HZ0
	bcc no_new_frame
new_frame
	lda $14
	sec
	sbc #HZ0
	sta $14
	lda $15
	sbc #HZ1
	sta $15
	lda $16
	sbc #HZ2
	sta $16
	lda $17
	sbc #HZ3
	sta $17

	inc $18

no_new_frame

	lda $18
	beq no_frames
	
	.(
	lda $08
	bne busy

	; busy
	lda #1
	sta $08

	; decrement number of outstanding frames to render.
	dec $18
	
	; enable interrupts to do the actual rendering.
	cli
	jsr render
	sei
		
	; not busy
	stz $08
	
busy
	.)
no_frames

	ply
	plx
	pla
	plp
	rts
	.)

render
	.(
	ldx $09
	lda $0b,x
	bne ready
	; if buffer isn't ready, drop out now (and re-queue frame).
	inc $18
	rts
ready
	; if a video block load stalled previously, retry it now.
	lda $19
	.(
	beq no_newblock
	jmp newblock
no_newblock
	.)
	
	lda ($00)
	cmp #127
	.(
	bne notnew
	jmp newblock
notnew	.)
	cmp #255
	.(
	bne notraw
	jmp rawframe
notraw	.)
	bit #$80
	bne diffframe
		
rleframe
	sta $06
	
	;lda #'R'
	;jsr oswrch
	
	; skip over frame type byte.
	inc $00
	.(
	bne nohi
	inc $01
nohi	.)
	
	.(
do_spans
	lda $06
	beq spans_done
	dec $06
	
	; a run-length encoded frame.
	lda ($00)
	sta $02
	ldy #1
	lda ($00), y
	sta $03
	iny
	lda ($00), y
	tax
	; now ($02) is the span start, X is the (uncompressed) length.
	lda $00
	clc
	adc #3
	sta $00
	.(
	bcc nohi
	inc $01
nohi	.)
	
	stz $05
rlespans
	ldy $05
	; get repeat count
	lda ($00), y
	; stow repeat count in $04
	sta $04
	iny
	; get byte to write
	lda ($00), y
	iny
	; store Y index in $05
	sty $05

	; now A has byte to write, $04 has repeat count (where 0 means 256).
	ldy $04
	.(
fill
	dey
	sta ($02), y
	bne fill
	.)
	
	; add run-length to screen ptr, treating $04==0 as $04==256.
	.(
	lda $04
	beq skip256
	clc
	adc $02
	sta $02
	bcc nohi
skip256
	inc $03
nohi	.)
	
	; subtract the length of this span from total (X).
	.(
	lda $04
	beq xtozero
	txa
	sec
	sbc $04
xtozero
	tax
	.)
	
	bne rlespans
	
	; add RLE data length to frame pointer.
	.(
	lda $00
	clc
	adc $05
	sta $00
	bcc nohi
	inc $01
nohi	.)

	jmp do_spans

spans_done
	.)

	rts

diffframe
	; number of spans in $04.
	and #$7f
	sta $04
	
	;lda #'D'
	;jsr oswrch
	
	; skip over frame type byte.
	inc $00
	.(
	bne nohi
	inc $01
nohi	.)
	
	.(
do_span
	lda $04
	beq all_done

	dec $04
	
	lda ($00)
	sta $02
	ldy #1
	lda ($00), y
	sta $03
	iny
	lda ($00), y
	; keep (uncompressed span) length in $05.
	sta $05
	tay
	; now ($02) is span start, Y is the length.
	; advance ($00) to data.
	lda $00
	clc
	adc #3
	sta $00
	.(
	bcc nohi
	inc $01
nohi	.)
	
fill
	dey
	lda ($00), y
	sta ($02), y
	cpy #0
	bne fill
	
	; skip ($00) over data, treating $05==0 as $05=256.
	.(
	lda $05
	beq skip256
	clc
	adc $00
	sta $00
	bcc nohi
skip256
	inc $01
nohi	.)
	
	jmp do_span
	
all_done
	rts
	.)

rawframe
	.(
	
	;lda #'W'
	;jsr oswrch
	
	; skip over frame-type byte
	inc $00
	.(
	bne nohi
	inc $01
nohi	.)

	lda #<$7C00
	ldx #>$7C00
	sta $02
	stx $03
	
	; copy src pointer
	lda $00
	ldx $01
	sta $04
	stx $05

	ldx #3
	ldy #0
copy
	lda ($04), y
	sta ($02), y
	dey
	bne copy

	inc $05
	inc $03
	dex
	bne copy
	
	ldy #0
copy2
	lda ($04), y
	sta ($02), y
	iny
	cpy #232
	bne copy2
	
	; add frame size to frame ptr
	lda $00
	clc
	adc #<1000
	sta $00
	lda $01
	adc #>1000
	sta $01

	rts
	.)

newblock
	.(
	lda $0a
	beq req_clear
	; mark block-load stalled.
	lda #1
	sta $19
	; re-queue frame.
	inc $18
	rts
req_clear
	stz $19
	.)

	lda $09
	bne buftwo
		
	; switch to second buffer
	stz $00
	lda #$6C
	sta $01
	; request reload of first buffer (should be atomic!)
	lda #1
	sei
	sta $0a
	; second buffer active.
	sta $09
	; buffer 1 not ready.
	stz $0b
	cli
	
	jmp switched
buftwo
	; switch to first buffer
	stz $00
	lda #$5C
	sta $01
	; request reload of second buffer (likewise.)
	lda #2
	sei
	sta $0a
	; first buffer active.
	stz $09
	; buffer 2 not ready.
	stz $0c
	cli
switched

	jmp render

	; end of render.
	.)

; Initialise $11,$10 to point to sound data (first 4K buffer, at $3c00).
; $12 tells which block is active (0/1).
initptr
	.(
	lda #<$3C00
	ldx #>$3C00
	sta $10
	stx $11
	stz $12
	stz $13
	; synch counters.
	stz $14
	stz $15
	stz $16
	stz $17
	rts
	.)

#define SYS_T1C_L $fe44
#define SYS_T1C_H $fe45
#define SYS_T1L_L $fe46
#define SYS_T1L_H $fe47
#define SYS_T2C_L $fe48
#define SYS_T2C_H $fe49
#define SYS_SR $fe4a
#define SYS_ACR $fe4b
#define SYS_PCR $fe4c
#define SYS_IFR $fe4d
#define SYS_IER $fe4e

#define USR_T1C_L $fe64
#define USR_T1C_H $fe65
#define USR_T1L_L $fe66
#define USR_T1L_H $fe67
#define USR_T2C_L $fe68
#define USR_T2C_H $fe69
#define USR_SR $fe6a
#define USR_ACR $fe6b
#define USR_PCR $fe6c
#define USR_IFR $fe6d
#define USR_IER $fe6e

oldirq1v
	.word 0

inittimer1irq
	.(
	lda $204
	ldx $205
	sta oldirq1v
	stx oldirq1v+1
	
	sei

	; Continuous interrupts for timer 1.
	lda USR_ACR
	and #$3f
	ora #$40
	sta USR_ACR

	; Point at irq handler.
	lda #<irqhandler
	ldx #>irqhandler
	sta $204
	stx $205

	; Enable Usr timer 1 interrupt.
	lda #$c0
	sta USR_IER

	lda #<RHZ
	ldx #>RHZ
	sta USR_T1C_L
	stx USR_T1C_H

	; Disable System VIA interrupts.
	lda #$7f
	sta SYS_IER
	; Enable system timer 1 and CA1 (vsync).
	lda #$c1
	sta SYS_IER

	cli
	
	rts
	.)

soundstrobe
	.(
	sta $fe41
	; strobe is supposed to be at least 8uS. This should do.
	stz $fe40
	nop
	nop
	lda #$08
	sta $fe40
	rts
	.)

; initialise sound frequencies on 3 channels.
initfreq
	.(
	sei
	
	lda #$ff
	sta $fe43
	
	; channel 3
	lda #$83
	jsr soundstrobe
	lda #$00
	jsr soundstrobe
	
	; channel 2
	lda #$a3
	jsr soundstrobe
	lda #$00
	jsr soundstrobe
	
	; channel 1
	lda #$c3
	jsr soundstrobe
	lda #$00
	jsr soundstrobe
	
	cli
	rts
	.)

; $14,$15,$16,$17 are sample counter.

exitirq
	.(
	lda #$82
	bit SYS_IFR
	; top bit clear - not irq from sys via
	bpl done
	and #2
	beq done
	
	; clear CA1 interrupt
	lda #2
	sta SYS_IFR

	jsr render_event	

done
	pla
	sta $fc
	jmp (oldirq1v)
	.)

irqhandler
	.(
	lda $fc
	pha

	lda #$c0
	bit USR_IFR
	; top bit clear - not interrupt from 6522 (user VIA).
	bpl exitirq
	; bit 6 clear - not our interrupt, process next in chain.
	bvc exitirq

	; Clear timer1 interrupt flag.
	lda USR_T1C_L
	
	; want Y too.
	phy
		
	; play sample!
	
	; set 'slow' databus lines to output (might not need to do this each
	; cycle?)
	;lda #$ff
	;sta $fe43
		
	lda ($10)
	
	bpl allchannels
	
	; inlined below.
	;jsr soundstrobe
	
write_and_incr
	sta $fe41
	stz $fe40
	; synch counter
	clc
	lda $14
	adc #<3000
	sta $14
	lda $15
	adc #>3000
	sta $15
	lda $16
	adc #0
	sta $16
	.(
	bcc nohi
	inc $17
nohi	.)
	
	lda #$08
	sta $fe40
	
	jmp played_samp

allchannels
	; todo -- glitch sequence ordering.
	and #15
	tay
	ora #$90
	jsr soundstrobe
	tya
	ora #$b0
	jsr soundstrobe
	tya
	ora #$d0
	;jsr soundstrobe
	jmp write_and_incr

played_samp
	; just for shits & giggles
	;lda #0
	;sta ($10)

	; move to next sample / check for end-of-buffer.
	inc $10
	.(
	bne nohi
	lda $12
	bne buftwo
	inc $11
	lda $11
	cmp #$4c
	bcc nohi
	; switch to second buffer.
	lda #1
	sta $12
	; request reload of buffer 1.
	sta $13
	stz $10
	lda #$4c
	sta $11
	jmp nohi
buftwo
	inc $11
	lda $11
	cmp #$5c
	bcc nohi
	; switch to first buffer.
	stz $12
	; request reload of buffer 2.
	lda #2
	sta $13
	stz $10
	lda #$3c
	sta $11
nohi
	.)
	
	; handled our interrupt, don't chain to next.
	ply
	pla
	sta $fc
	rti

	.)
